* Pre-IB computer science project
** Short overview
   - The project allows you to increase your final grade by a maximum
     of 3 grades (maximum level 3 in grading levels below)
   - Your program must process text data in a meaningful way, but the
     end result does not have to be a real-life application.
   - Grading is based on
     - specification
     - correctness and exception handling
     - code clarity
     - resource management.
   - Your submission consists of
     - one file containing documentation:
       - your target assessment level (1, 2 or 3)
       - specification
       - format of input
       - test case with typical input
       - explanation of exception handling (levels 2 and 3)
       - explanation of resource handling (level 3)
     - one ~.java~-file containing the code
     - possibly one or more text data files needed for the test case.
   - Submission is made via email by providing either
     - one ~.zip~-archive containing all files, or
     - a link to a GitHub repository containing all files.
** Grading levels
*** Criteria for level 1
**** Specification
     - There is a sensible description of what the program does.
     - The program reads some input from user and/or from a text data
       file.
     - Format of input is explained clearly.
**** Correctness and exception handling
     - The program works correctly in one documented test case with
       typical input.
     - If any text data files are required to test this, they are
       supplied.
**** Code clarity
     - Code is indented correctly.
     - There is no unnecessary whitespace (no extra empty lines or
       extra spaces).
     - Identifiers (names of variables, constants and functions) are
       meaningful in the context of the program.
*** Additional criteria for level 2
**** Correctness and exception handling
     - At least one exception is caught and reported correctly.  This
       is also documented.
**** Code clarity
     - Constants are identified and named.
     - The flow of the program is split into meaningful functions
       called by ~main()~.
     - The operation of defined functions is explained in comments.
*** Additional criteria for level 3
**** Correctness and exception handling
     - The correct working of the program has been documented in all
       possible special cases (except for the computer running out of
       memory). That is, your program will not throw an exception
       (unless your computer runs out of memory).
**** Resource management
     - At least one resource is freed when no longer needed, even in
       the case of an exception. This is also documented.
**** Code clarity
     - All non-trivial parts of the code are commented.
     - If appropriate, classes are defined for program-specific data
       types.
** Example
*** Specification
    - The program
      1. reads data about persons from a file
      2. prints data of persons with identical first names (namesakes)
         on consecutive rows.
    - The input data text file consists of rows, each row containing
      #+begin_quote
      lastname firstname address
      #+end_quote
    - The user supplies the name of the input file either as a program
      argument, or if none is given, from keyboard.
*** Code
    #+begin_src java :exports code :tangle yes
      import java.io.File;
      import java.io.FileReader;
      import java.util.Scanner;

      class NamesakeListing
      {
        public static void main (String[] args)
        {
          final int MAX_NUM_PERSONS = 10;

          // get name of data file
          String filename;
          if (args.length >= 1)
            filename = args [0];
          else
            filename = queryFilename ();

          // read persons into an array
          Person[] persons = new Person [MAX_NUM_PERSONS];
          int numPersons = readPersons (filename, persons);

          // list namesakes
          printNamesakes (persons, numPersons);
        }

        // query the user for the name of data file; return value is the
        // name of the file
        static String queryFilename ()
        {
          String filename;
          try (Scanner scanner = new Scanner (System.in))
          {
            System.out.print ("give data file name: ");
            filename = scanner.next ();
          }
          catch (Exception e)
          {
            System.out.println ("unable to read data file name, exception: " + e);
            filename = "";
            System.exit (-1);
          }

          return filename;
        }

        // read persons from data file with given file name into the
        // supplied array; return value is the number of persons in the data
        // file
        static int readPersons (String filename, Person[] persons)
        {
          int numPersons = 0;

          // open file and create a scanner for it
          try (FileReader dataFileReader = new FileReader (new File (filename));
               Scanner scanner = new Scanner (dataFileReader))
          {
            try
            {
              // read while there are lines in the file
              while (scanner.hasNextLine ())
              {
                if (numPersons > persons.length)
                {
                  System.out.println ("exceeded maximum number of persons " + persons.length);
                  System.exit (-1);
                }

                // each line has last name, first name, address
                String lastname = scanner.next ();
                String firstname = scanner.next ();
                String address = scanner.nextLine (); // address is the rest of the line

                persons [numPersons] = new Person (lastname, firstname, address);
                numPersons = numPersons + 1;
              }
            }
            catch (Exception e)
            {
              System.out.println ("unable to read person data, exception " + e);
              System.exit (-1);
            }
          }
          catch (Exception e)
          {
            System.out.println ("unable to open file " + filename + " for reading, exception : " + e);
            System.exit (-1);
          }

          return numPersons;
        }

        // print the persons as groups of namesakes
        static void printNamesakes (Person[] persons, int numPersons)
        {
          // go through the persons
          for (int personInd = 0; personInd < numPersons; personInd = personInd + 1)
          {
            Person person = persons [personInd];

            // if the person has not been printed yet, print the person and
            // the possible namesakes
            if (person != null)
            {
              System.out.println (person);

              // go through namesake candidates, starting from the next
              // person
              for (int candInd = personInd + 1; candInd < numPersons; candInd = candInd + 1)
              {
                Person candidate = persons [candInd];
                if (candidate != null && person.isNamesake (candidate))
                {
                  System.out.println (candidate);
                  persons [candInd] = null;
                }
              }
            }
          } 
        }
      }


      // class containing information of person and converting info to
      // string
      class Person
      {
        public Person (String lastname, String firstname, String address)
        {
          this.lastname = lastname;
          this.firstname = firstname;
          this.address = address;
        }

        public boolean isNamesake (Person person)
        {
          return firstname.equals (person.firstname);
        }

        public String toString ()
        {
          return lastname + " " + firstname + " " + address;
        }

        public String firstname, lastname, address;
      }

    #+end_src
