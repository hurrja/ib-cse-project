* Pre-IB computer science project
** Short overview
   - The project allows you to increase your final grade by a maximum
     of 3 grades (maximum level 3 in grading levels below)
   - Your program must process text data in a meaningful way, but the
     end result does not have to be a real-life application.
   - Grading is based on
     - specification
     - correctness and exception handling
     - code clarity
     - resource management.
   - Your submission consists of
     - one document with problem specification and description of test
       cases
     - one ~.java~-file containing the code
     - possibly one or more text data files.
   - Submission is made via email by providing either
     - one ~.zip~-archive, or
     - a link to a GitHub repository containing all files.
** Grading levels
*** Criteria for level 1
**** Specification
     - There is a sensible specification of what the program does.
     - The program reads some input from user and/or from a text data
       file.
     - All required text data files, if any, are supplied.
**** Correctness and exception handling
     The program works correctly in one documented test case with
     typical input.
**** Code clarity
     - Code is correctly indented.
     - There is no unnecessary whitespace (no extra empty lines or
       extra spaces).
     - Identifiers (names of variables, constants and functions) are
       meaningful in the context of the program.
*** Additional criteria for level 2
**** Correctness and exception handling
     - At least one exception is caught and reported correctly, and
       this is documented (explained in document).
**** Code clarity
     - Constants are identified and named.
     - A meaningful function is defined in the program and called by
       ~main()~.
     - The most complex part of the code is explained with a comment.
*** Additional criteria for level 3
**** Correctness and exception handling
     - The correct working of the program has been documented in /all/
       possible special cases except for the computer running out of
       memory. That is, your program will never throw an exception.
**** Resource management
     - Documentation explains how at least one resource is freed when
       no longer needed.
**** Code clarity
     - All non-trivial parts of the code are commented.
     - The role and operation of all functions and/or classes are
       explained in comments.
** Example
*** Specification
    - The program
      1. reads data about persons from a file
      2. prints data of persons with identical first names (namesakes)
         on consecutive rows.
    - The input data text file consists of rows, each row containing
      #+begin_quote
      lastname firstname address
      #+end_quote
    - The user supplies the name of the input file either as a program
      argument, or if none is given, from keyboard.
*** Code
    #+begin_src java :exports code :tangle yes
      import java.io.File;
      import java.io.FileReader;
      import java.util.Scanner;

      class NamesakeListing
      {
        public static void main (String[] args)
        {
          final int MAX_NUM_PERSONS = 10;

          // get name of data file
          String filename;
          if (args.length >= 1)
            filename = args [0];
          else
            filename = queryFilename ();

          // read persons into an array
          Person[] persons = new Person [MAX_NUM_PERSONS];
          int numPersons = readPersons (filename, persons);

          // list namesakes
          printNamesakes (persons, numPersons);
        }

        // query the user for the name of data file; return value is the
        // name of the file
        static String queryFilename ()
        {
          String filename;
          try (Scanner scanner = new Scanner (System.in))
          {
            System.out.print ("give data file name: ");
            filename = scanner.next ();
          }
          catch (Exception e)
          {
            System.out.println ("unable to read data file name, exception: " + e);
            filename = "";
            System.exit (-1);
          }

          return filename;
        }

        // read persons from data file with given file name into the
        // supplied array; return value is the number of persons in the data
        // file
        static int readPersons (String filename, Person[] persons)
        {
          int numPersons = 0;

          // open file and create a scanner for it
          try (FileReader dataFileReader = new FileReader (new File (filename));
               Scanner scanner = new Scanner (dataFileReader))
          {
            try
            {
              // read while there are lines in the file
              while (scanner.hasNextLine ())
              {
                if (numPersons > persons.length)
                {
                  System.out.println ("exceeded maximum number of persons " + persons.length);
                  System.exit (-1);
                }

                // each line has last name, first name, address
                String lastname = scanner.next ();
                String firstname = scanner.next ();
                String address = scanner.nextLine (); // address is the rest of the line

                persons [numPersons] = new Person (lastname, firstname, address);
                numPersons = numPersons + 1;
              }
            }
            catch (Exception e)
            {
              System.out.println ("unable to read person data, exception " + e);
              System.exit (-1);
            }
          }
          catch (Exception e)
          {
            System.out.println ("unable to open file " + filename + " for reading, exception : " + e);
            System.exit (-1);
          }

          return numPersons;
        }

        // print the persons as groups of namesakes
        static void printNamesakes (Person[] persons, int numPersons)
        {
          // go through the persons
          for (int personInd = 0; personInd < numPersons; personInd = personInd + 1)
          {
            Person person = persons [personInd];

            // if the person has not been printed yet, print the person and
            // the possible namesakes
            if (person != null)
            {
              System.out.println (person);

              // go through namesake candidates, starting from the next
              // person
              for (int candInd = personInd + 1; candInd < numPersons; candInd = candInd + 1)
              {
                Person candidate = persons [candInd];
                if (candidate != null && person.isNamesake (candidate))
                {
                  System.out.println (candidate);
                  persons [candInd] = null;
                }
              }
            }
          } 
        }
      }


      // class containing information of person and converting info to
      // string
      class Person
      {
        public Person (String lastname, String firstname, String address)
        {
          this.lastname = lastname;
          this.firstname = firstname;
          this.address = address;
        }

        public boolean isNamesake (Person person)
        {
          return firstname.equals (person.firstname);
        }

        public String toString ()
        {
          return lastname + " " + firstname + " " + address;
        }

        public String firstname, lastname, address;
      }

    #+end_src
